name: Build Swift App

on:
  push:
    branches: [ main, swifty ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, swifty ]

jobs:
  build-swift-app:
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Build Swift app
      working-directory: MCPServerManager
      run: |
        # Build for native architecture
        swift build -c release

        # Verify binary was created
        ls -la .build/release/
        file .build/release/MCPServerManager

    - name: Create app bundle
      working-directory: MCPServerManager
      run: |
        # Create .app structure
        mkdir -p build/MCP-Server-Manager.app/Contents/MacOS
        mkdir -p build/MCP-Server-Manager.app/Contents/Resources
        mkdir -p build/MCP-Server-Manager.app/Contents/Frameworks

        # Copy binary
        cp .build/release/MCPServerManager build/MCP-Server-Manager.app/Contents/MacOS/

        # Fix rpath in binary to point to Frameworks directory
        install_name_tool -add_rpath "@executable_path/../Frameworks" build/MCP-Server-Manager.app/Contents/MacOS/MCPServerManager

        # Copy Sparkle framework
        cp -R .build/release/Sparkle.framework build/MCP-Server-Manager.app/Contents/Frameworks/

        # Copy app icon
        cp icons/AppIcon.icns build/MCP-Server-Manager.app/Contents/Resources/AppIcon.icns

        # Create Info.plist
        cat > build/MCP-Server-Manager.app/Contents/Info.plist << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>MCPServerManager</string>
            <key>CFBundleIdentifier</key>
            <string>com.mcpmanager.app</string>
            <key>CFBundleName</key>
            <string>MCP Server Manager</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleShortVersionString</key>
            <string>2.0.2.${{ github.run_number }}</string>
            <key>CFBundleVersion</key>
            <string>${{ github.run_number }}</string>
            <key>LSMinimumSystemVersion</key>
            <string>13.0</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
            <key>SUFeedURL</key>
            <string>https://github.com/${{ github.repository }}/releases/download/latest/appcast.xml</string>
            <key>SUPublicEDKey</key>
            <string>SnkRxHZxaHrqHMoSW/Ls6dbeqZaGZBlS5AQ9I8OE3JI=</string>
            <key>SUEnableAutomaticChecks</key>
            <true/>
            <key>SUAutomaticallyUpdate</key>
            <false/>
            <key>SUAllowsAutomaticUpdates</key>
            <true/>
        </dict>
        </plist>
        EOF

    - name: Import certificates
      env:
        MAC_APP_STORE_CERT: ${{ secrets.MAC_APP_STORE_CERT }}
        MAC_INSTALLER_CERT: ${{ secrets.MAC_INSTALLER_CERT }}
        MAC_CERTS: ${{ secrets.MAC_CERTS }}
        CERT_PASSWORD: ${{ secrets.CERT_PASSWORD }}
      run: |
        # Create temporary keychain
        security create-keychain -p actions build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p actions build.keychain
        security set-keychain-settings -t 3600 -u build.keychain

        # Decode and import Developer ID certificates (MAC_CERTS - likely contains Developer ID Application)
        if [ -n "$MAC_CERTS" ]; then
          echo "$MAC_CERTS" | base64 --decode > developer_id_cert.p12
          security import developer_id_cert.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            security import developer_id_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            echo "⚠️ Failed to import MAC_CERTS certificate (wrong password or corrupted file)"
          rm -f developer_id_cert.p12
        fi

        # Decode and import App Store signing certificate
        if [ -n "$MAC_APP_STORE_CERT" ]; then
          echo "$MAC_APP_STORE_CERT" | base64 --decode > appstore_cert.p12
          # Try with password first, then without if it fails
          security import appstore_cert.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            security import appstore_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            echo "⚠️ Failed to import MAC_APP_STORE_CERT certificate (wrong password or corrupted file)"
          rm -f appstore_cert.p12
        fi

        # Decode and import Installer certificate
        if [ -n "$MAC_INSTALLER_CERT" ]; then
          echo "$MAC_INSTALLER_CERT" | base64 --decode > installer_cert.p12
          security import installer_cert.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            security import installer_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            echo "⚠️ Failed to import MAC_INSTALLER_CERT certificate (wrong password or corrupted file)"
          rm -f installer_cert.p12
        fi

        # Set partition list
        security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k actions build.keychain

        # Verify certificates
        echo "Imported certificates:"
        security find-identity -v -p codesigning

    - name: Sign app bundle
      working-directory: MCPServerManager
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        # Find the signing identity
        echo "Available signing identities:"
        security find-identity -v -p codesigning

        # Get the first valid Developer ID or Mac App Store certificate
        # Prefer Developer ID Application for direct distribution, but accept App Store certs as fallback
        IDENTITY=$(security find-identity -v -p codesigning | grep -E "Developer ID Application|Apple Distribution|3rd Party Mac Developer Application" | head -1 | awk -F'"' '{print $2}')

        if [ -z "$IDENTITY" ]; then
          echo "❌ No valid signing identity found"
          echo "⚠️  App will not be signed - may show 'damaged' error on macOS"
          exit 0
        fi

        echo "Signing with identity: $IDENTITY"

        # Sign the app bundle with hardened runtime
        # Note: Using relaxed entitlements for direct distribution (DMG)
        # App Store builds should NOT use these entitlements
        # Using --deep to sign embedded frameworks (like Sparkle.framework)
        codesign --force --deep --sign "$IDENTITY" \
          --options runtime \
          --entitlements ../entitlements.plist \
          --timestamp \
          build/MCP-Server-Manager.app || {
            echo "⚠️  Signing with entitlements failed, trying without..."
            codesign --force --deep --sign "$IDENTITY" \
              --options runtime \
              --timestamp \
              build/MCP-Server-Manager.app
          }

        # Verify the signature
        echo "Verifying signature..."
        codesign --verify --verbose build/MCP-Server-Manager.app
        echo "✓ App bundle signed successfully"

    - name: Install create-dmg tool
      run: brew install create-dmg

    - name: Install Sparkle tools
      run: |
        # Download and install Sparkle's generate_appcast tool
        curl -L https://github.com/sparkle-project/Sparkle/releases/download/2.5.2/Sparkle-2.5.2.tar.xz -o sparkle.tar.xz
        tar -xf sparkle.tar.xz
        chmod +x bin/generate_appcast
        sudo cp bin/generate_appcast /usr/local/bin/

    - name: Create DMG
      working-directory: MCPServerManager
      run: |
        # Create installer DMG with Applications symlink
        VERSION="2.0.2.${{ github.run_number }}"
        bash ../create-dmg.sh build/MCP-Server-Manager.app "build/MCP-Server-Manager-v${VERSION}.dmg"

        # Also create a "latest" symlink for consistent naming
        cd build
        ln -sf "MCP-Server-Manager-v${VERSION}.dmg" MCP-Server-Manager.dmg

    - name: Notarize and staple DMG
      continue-on-error: true
      working-directory: MCPServerManager
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        VERSION="2.0.2.${{ github.run_number }}"
        DMG_PATH="build/MCP-Server-Manager-v${VERSION}.dmg"

        if [ -z "$APPLE_ID" ] || [ -z "$APPLE_APP_SPECIFIC_PASSWORD" ]; then
          echo "⚠️  Notarization credentials not found - skipping notarization"
          echo "   DMG may show 'damaged' error on other Macs"
          exit 0
        fi

        echo "Submitting DMG for notarization..."

        # Submit for notarization and capture the output
        xcrun notarytool submit "$DMG_PATH" \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_APP_SPECIFIC_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait 2>&1 | tee notary_output.txt

        # Check if notarization was accepted
        if grep -q "status: Accepted" notary_output.txt; then
          echo "✓ Notarization successful"

          # Staple the notarization ticket to the DMG
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"
          echo "✓ DMG notarized and stapled"
        else
          echo "⚠️  Notarization failed or returned Invalid status"
          echo "   DMG is code-signed but not notarized - may show warning on first open"
          echo "   Users can right-click > Open to bypass the warning"
          exit 0
        fi

    - name: Generate Release Notes from CHANGELOG
      id: release_notes
      env:
        RUN_NUMBER: ${{ github.run_number }}
      run: |
        VERSION="2.0.2.${RUN_NUMBER}"

        # Extract [Unreleased] section from CHANGELOG.md
        bash extract-changelog.sh CHANGELOG.md MCPServerManager/build/release-notes.html MCPServerManager/build/release-notes.md

        # Add version info to HTML
        cat >> MCPServerManager/build/release-notes.html << VERSION_INFO
          <p style="margin-top: 20px; font-size: 12px; color: #666;">
            <strong>Version:</strong> ${VERSION}<br>
            <strong>Build:</strong> ${RUN_NUMBER}
          </p>
        </body>
        </html>
        VERSION_INFO

        echo "✓ Release notes generated from CHANGELOG.md"

    - name: Generate and Sign Appcast
      working-directory: MCPServerManager/build
      env:
        REPO: ${{ github.repository }}
        RUN_NUMBER: ${{ github.run_number }}
        SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
      run: |
        VERSION="2.0.2.${RUN_NUMBER}"
        PUBDATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
        DMG_PATH="MCP-Server-Manager-v${VERSION}.dmg"

        # Get DMG file size and signature
        DMG_SIZE=$(stat -f%z "$DMG_PATH" 2>/dev/null || stat -c%s "$DMG_PATH" 2>/dev/null || echo "0")

        # Read release notes HTML and escape for XML
        RELEASE_NOTES=$(<release-notes.html)

        # Create temp directory for archives
        mkdir -p archives
        cp "$DMG_PATH" "archives/"
        cp release-notes.html "archives/${VERSION}.html"

        # Create private key file for Sparkle signing
        if [ -n "$SPARKLE_PRIVATE_KEY" ]; then
          # Write the key to file (ensure proper line endings)
          printf "%s" "$SPARKLE_PRIVATE_KEY" > sparkle_private_key.txt

          # Debug: Check if key file was created
          if [ ! -s sparkle_private_key.txt ]; then
            echo "⚠️  Error: Private key file is empty"
            echo "⚠️  Falling back to unsigned appcast"
          else
            echo "✓ Private key file created ($(wc -c < sparkle_private_key.txt) bytes)"

            # Use generate_appcast with the archives directory
            # This will scan the archives folder and generate a signed appcast
            /usr/local/bin/generate_appcast \
              --ed-key-file sparkle_private_key.txt \
              --download-url-prefix "https://github.com/${REPO}/releases/download/latest/" \
              --release-notes-url-prefix "https://github.com/${REPO}/releases/download/latest/" \
              archives/ || echo "⚠️  generate_appcast failed, will fall back to unsigned"
          fi

          # Move generated appcast to current directory
          if [ -f archives/appcast.xml ]; then
            mv archives/appcast.xml .
            echo "✓ Signed appcast generated successfully"
          else
            echo "⚠️  generate_appcast failed, creating unsigned appcast"
            # Fallback to unsigned appcast with inline release notes
            cat > appcast.xml << APPCAST_EOF
        <?xml version="1.0" encoding="utf-8"?>
        <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
          <channel>
            <title>MCP Server Manager</title>
            <language>en</language>
            <item>
              <title>Version ${VERSION}</title>
              <pubDate>${PUBDATE}</pubDate>
              <sparkle:version>${VERSION}</sparkle:version>
              <sparkle:shortVersionString>2.0.2</sparkle:shortVersionString>
              <link>https://github.com/${REPO}/releases</link>
              <sparkle:releaseNotesLink>https://github.com/${REPO}/releases/download/latest/${VERSION}.html</sparkle:releaseNotesLink>
              <description><![CDATA[
                ${RELEASE_NOTES}
              ]]></description>
              <enclosure url="https://github.com/${REPO}/releases/download/latest/${DMG_PATH}"
                         length="${DMG_SIZE}"
                         type="application/octet-stream"/>
            </item>
          </channel>
        </rss>
        APPCAST_EOF
            echo "✓ Unsigned appcast created with release notes"
          fi

          # Cleanup
          rm -f sparkle_private_key.txt
        else
          echo "⚠️  SPARKLE_PRIVATE_KEY not set - creating unsigned appcast"
          # Create unsigned appcast with inline release notes
          cat > appcast.xml << APPCAST_EOF
        <?xml version="1.0" encoding="utf-8"?>
        <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
          <channel>
            <title>MCP Server Manager</title>
            <language>en</language>
            <item>
              <title>Version ${VERSION}</title>
              <pubDate>${PUBDATE}</pubDate>
              <sparkle:version>${VERSION}</sparkle:version>
              <sparkle:shortVersionString>2.0.2</sparkle:shortVersionString>
              <link>https://github.com/${REPO}/releases</link>
              <sparkle:releaseNotesLink>https://github.com/${REPO}/releases/download/latest/${VERSION}.html</sparkle:releaseNotesLink>
              <description><![CDATA[
                ${RELEASE_NOTES}
              ]]></description>
              <enclosure url="https://github.com/${REPO}/releases/download/latest/${DMG_PATH}"
                         length="${DMG_SIZE}"
                         type="application/octet-stream"/>
            </item>
          </channel>
        </rss>
        APPCAST_EOF
          echo "✓ Unsigned appcast created with release notes"
        fi

    - name: List build artifacts
      run: |
        echo "Build directory contents:"
        ls -la MCPServerManager/build/ || echo "No build directory"
        find . -name "*.dmg" -type f || echo "No DMG files found"
        find . -name "*.app" -type d || echo "No APP bundles found"
        find . -name "appcast.xml" -type f || echo "No appcast.xml found"

    - name: Upload DMG artifact
      uses: actions/upload-artifact@v4
      if: success()
      with:
        name: mcp-server-manager-v2.0.2.${{ github.run_number }}
        path: MCPServerManager/build/MCP-Server-Manager-v*.dmg
        retention-days: 30

    - name: Delete old latest release
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/swifty'
      run: |
        gh release delete latest -y || true
        git push origin :refs/tags/latest || true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create or Update Release
      uses: softprops/action-gh-release@v1
      if: startsWith(github.ref, 'refs/tags/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/swifty'
      with:
        tag_name: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || 'latest' }}
        name: ${{ startsWith(github.ref, 'refs/tags/') && format('Release {0}', github.ref_name) || format('Latest Build v2.0.2.{0}', github.run_number) }}
        body_path: MCPServerManager/build/release-notes.md
        generate_release_notes: false
        prerelease: false
        files: |
          MCPServerManager/build/MCP-Server-Manager-v*.dmg
          MCPServerManager/build/appcast.xml
          MCPServerManager/build/*.html
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
