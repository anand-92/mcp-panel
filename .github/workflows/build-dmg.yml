name: Build Swift App

on:
  push:
    branches: [ main, swifty ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, swifty ]

jobs:
  build-swift-app:
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Install xcodegen
      run: brew install xcodegen

    - name: Import certificates
      env:
        MAC_APP_STORE_CERT: ${{ secrets.MAC_APP_STORE_CERT }}
        MAC_INSTALLER_CERT: ${{ secrets.MAC_INSTALLER_CERT }}
        MAC_CERTS: ${{ secrets.MAC_CERTS }}
        CERT_PASSWORD: ${{ secrets.CERT_PASSWORD }}
      run: |
        # Create temporary keychain
        security create-keychain -p actions build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p actions build.keychain
        security set-keychain-settings -t 3600 -u build.keychain

        # Decode and import Developer ID certificates (MAC_CERTS - likely contains Developer ID Application)
        if [ -n "$MAC_CERTS" ]; then
          echo "$MAC_CERTS" | base64 --decode > developer_id_cert.p12
          security import developer_id_cert.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            security import developer_id_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            echo "‚ö†Ô∏è Failed to import MAC_CERTS certificate (wrong password or corrupted file)"
          rm -f developer_id_cert.p12
        fi

        # Decode and import App Store signing certificate
        if [ -n "$MAC_APP_STORE_CERT" ]; then
          echo "$MAC_APP_STORE_CERT" | base64 --decode > appstore_cert.p12
          # Try with password first, then without if it fails
          security import appstore_cert.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            security import appstore_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            echo "‚ö†Ô∏è Failed to import MAC_APP_STORE_CERT certificate (wrong password or corrupted file)"
          rm -f appstore_cert.p12
        fi

        # Decode and import Installer certificate
        if [ -n "$MAC_INSTALLER_CERT" ]; then
          echo "$MAC_INSTALLER_CERT" | base64 --decode > installer_cert.p12
          security import installer_cert.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            security import installer_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A || \
            echo "‚ö†Ô∏è Failed to import MAC_INSTALLER_CERT certificate (wrong password or corrupted file)"
          rm -f installer_cert.p12
        fi

        # Set partition list
        security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k actions build.keychain

        # Verify certificates
        echo "Imported certificates:"
        security find-identity -v -p codesigning

    - name: Generate Xcode project and build with widget
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        # Generate Xcode project from project.yml
        xcodegen generate
        echo "‚úÖ Xcode project generated"

        # Restore entitlements (xcodegen resets them)
        cat > MCPServerManager/MCPServerManager/MCPServerManager.entitlements << 'ENTITLEMENTS'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.app-sandbox</key>
            <true/>
            <key>com.apple.security.files.user-selected.read-write</key>
            <true/>
            <key>com.apple.security.application-groups</key>
            <array>
                <string>group.com.anand-92.mcp-panel</string>
            </array>
        </dict>
        </plist>
        ENTITLEMENTS

        cat > MCPServerManagerWidget/MCPServerManagerWidget.entitlements << 'ENTITLEMENTS'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.app-sandbox</key>
            <true/>
            <key>com.apple.security.application-groups</key>
            <array>
                <string>group.com.anand-92.mcp-panel</string>
            </array>
        </dict>
        </plist>
        ENTITLEMENTS

        # Build with xcodebuild (includes widget extension)
        xcodebuild -project MCPServerManager.xcodeproj \
          -scheme MCPServerManager \
          -configuration Release \
          -derivedDataPath build \
          CODE_SIGNING_ALLOWED=NO \
          build

        echo "‚úÖ Build completed with widget extension"

        # Copy built app to expected location
        mkdir -p MCPServerManager/build
        cp -R build/Build/Products/Release/MCPServerManager.app MCPServerManager/build/MCP-Server-Manager.app

        # Verify widget is embedded
        if [ -d "MCPServerManager/build/MCP-Server-Manager.app/Contents/PlugIns/MCPServerManagerWidget.appex" ]; then
          echo "‚úÖ Widget extension embedded successfully"
        else
          echo "‚ö†Ô∏è Widget extension not found in app bundle"
          ls -la MCPServerManager/build/MCP-Server-Manager.app/Contents/PlugIns/ || echo "No PlugIns directory"
        fi

    - name: Add Sparkle framework and update Info.plist
      working-directory: MCPServerManager
      run: |
        # Download Sparkle framework
        curl -L https://github.com/sparkle-project/Sparkle/releases/download/2.5.2/Sparkle-2.5.2.tar.xz -o sparkle.tar.xz
        tar -xf sparkle.tar.xz

        # Copy Sparkle framework to app bundle
        mkdir -p build/MCP-Server-Manager.app/Contents/Frameworks
        cp -R Sparkle.framework build/MCP-Server-Manager.app/Contents/Frameworks/

        # Fix rpath in binary
        install_name_tool -add_rpath "@executable_path/../Frameworks" build/MCP-Server-Manager.app/Contents/MacOS/MCPServerManager 2>/dev/null || true

        # Copy app icon
        cp icons/AppIcon.icns build/MCP-Server-Manager.app/Contents/Resources/AppIcon.icns

        # Update Info.plist with Sparkle keys and version
        /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString 3.1.${{ github.run_number }}" build/MCP-Server-Manager.app/Contents/Info.plist
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ github.run_number }}" build/MCP-Server-Manager.app/Contents/Info.plist
        /usr/libexec/PlistBuddy -c "Add :SUFeedURL string https://github.com/${{ github.repository }}/releases/download/latest/appcast.xml" build/MCP-Server-Manager.app/Contents/Info.plist 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Set :SUFeedURL https://github.com/${{ github.repository }}/releases/download/latest/appcast.xml" build/MCP-Server-Manager.app/Contents/Info.plist
        /usr/libexec/PlistBuddy -c "Add :SUPublicEDKey string SnkRxHZxaHrqHMoSW/Ls6dbeqZaGZBlS5AQ9I8OE3JI=" build/MCP-Server-Manager.app/Contents/Info.plist 2>/dev/null || true
        /usr/libexec/PlistBuddy -c "Add :SUEnableAutomaticChecks bool true" build/MCP-Server-Manager.app/Contents/Info.plist 2>/dev/null || true
        /usr/libexec/PlistBuddy -c "Add :SUAllowsAutomaticUpdates bool true" build/MCP-Server-Manager.app/Contents/Info.plist 2>/dev/null || true

        echo "‚úÖ Sparkle framework and Info.plist updated"

    - name: Sign app bundle
      working-directory: MCPServerManager
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        # Find the signing identity
        echo "Available signing identities:"
        security find-identity -v -p codesigning

        # Get the first valid Developer ID or Mac App Store certificate
        IDENTITY=$(security find-identity -v -p codesigning | grep -E "Developer ID Application|Apple Distribution|3rd Party Mac Developer Application" | head -1 | awk -F'"' '{print $2}')

        if [ -z "$IDENTITY" ]; then
          echo "‚ùå No valid signing identity found"
          echo "‚ö†Ô∏è  App will not be signed - may show 'damaged' error on macOS"
          exit 0
        fi

        echo "Signing with identity: $IDENTITY"

        # Sign the widget extension first
        if [ -d "build/MCP-Server-Manager.app/Contents/PlugIns/MCPServerManagerWidget.appex" ]; then
          codesign --force --sign "$IDENTITY" \
            --options runtime \
            --entitlements ../MCPServerManagerWidget/MCPServerManagerWidget.entitlements \
            --timestamp \
            build/MCP-Server-Manager.app/Contents/PlugIns/MCPServerManagerWidget.appex
          echo "‚úÖ Widget extension signed"
        fi

        # Sign Sparkle framework components (inside-out)
        SPARKLE_PATH="build/MCP-Server-Manager.app/Contents/Frameworks/Sparkle.framework/Versions/B"

        # Sign XPC Services first
        if [ -d "$SPARKLE_PATH/XPCServices" ]; then
          find "$SPARKLE_PATH/XPCServices" -name "*.xpc" -type d | while read xpc; do
            echo "Signing XPC: $xpc"
            codesign --force --sign "$IDENTITY" --options runtime --timestamp "$xpc"
          done
        fi

        # Sign Updater.app
        if [ -d "$SPARKLE_PATH/Updater.app" ]; then
          echo "Signing Updater.app"
          codesign --force --sign "$IDENTITY" --options runtime --timestamp "$SPARKLE_PATH/Updater.app"
        fi

        # Sign Autoupdate binary
        if [ -f "$SPARKLE_PATH/Autoupdate" ]; then
          echo "Signing Autoupdate"
          codesign --force --sign "$IDENTITY" --options runtime --timestamp "$SPARKLE_PATH/Autoupdate"
        fi

        # Sign the Sparkle framework itself (after all nested components)
        echo "Signing Sparkle.framework"
        codesign --force --sign "$IDENTITY" \
          --options runtime \
          --timestamp \
          build/MCP-Server-Manager.app/Contents/Frameworks/Sparkle.framework

        # Sign the main app bundle
        codesign --force --sign "$IDENTITY" \
          --options runtime \
          --entitlements ../entitlements.plist \
          --timestamp \
          build/MCP-Server-Manager.app || {
            echo "‚ö†Ô∏è  Signing with entitlements failed, trying without..."
            codesign --force --sign "$IDENTITY" \
              --options runtime \
              --timestamp \
              build/MCP-Server-Manager.app
          }

        # Verify the signature
        echo "Verifying signature..."
        codesign --verify --verbose build/MCP-Server-Manager.app
        echo "‚úÖ App bundle signed successfully"

    - name: Install create-dmg tool
      run: brew install create-dmg

    - name: Install Sparkle tools
      run: |
        # Download and install Sparkle's generate_appcast tool
        curl -L https://github.com/sparkle-project/Sparkle/releases/download/2.5.2/Sparkle-2.5.2.tar.xz -o sparkle.tar.xz
        tar -xf sparkle.tar.xz
        chmod +x bin/generate_appcast
        sudo cp bin/generate_appcast /usr/local/bin/

    - name: Create DMG
      working-directory: MCPServerManager
      run: |
        # Create installer DMG with Applications symlink
        VERSION="3.1.${{ github.run_number }}"
        bash ../create-dmg.sh build/MCP-Server-Manager.app "build/MCP-Server-Manager-v${VERSION}.dmg"

        # Also create a "latest" symlink for consistent naming
        cd build
        ln -sf "MCP-Server-Manager-v${VERSION}.dmg" MCP-Server-Manager.dmg

    - name: Notarize and staple DMG
      continue-on-error: true
      working-directory: MCPServerManager
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        VERSION="3.1.${{ github.run_number }}"
        DMG_PATH="build/MCP-Server-Manager-v${VERSION}.dmg"

        if [ -z "$APPLE_ID" ] || [ -z "$APPLE_APP_SPECIFIC_PASSWORD" ]; then
          echo "‚ö†Ô∏è  Notarization credentials not found - skipping notarization"
          echo "   DMG may show 'damaged' error on other Macs"
          exit 0
        fi

        echo "Submitting DMG for notarization..."

        # Submit for notarization and capture the output
        xcrun notarytool submit "$DMG_PATH" \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_APP_SPECIFIC_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait 2>&1 | tee notary_output.txt

        # Check if notarization was accepted
        if grep -q "status: Accepted" notary_output.txt; then
          echo "‚úÖ Notarization successful"

          # Staple the notarization ticket to the DMG
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"
          echo "‚úÖ DMG notarized and stapled"
        else
          echo "‚ö†Ô∏è  Notarization failed or returned Invalid status"
          echo "   DMG is code-signed but not notarized - may show warning on first open"
          echo "   Users can right-click > Open to bypass the warning"

          # Fetch the notarization log to see why it failed
          SUBMISSION_ID=$(grep "id:" notary_output.txt | head -1 | awk '{print $2}')
          if [ -n "$SUBMISSION_ID" ]; then
            echo ""
            echo "üìã Fetching notarization log for submission: $SUBMISSION_ID"
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              notarization_log.json 2>&1 || true

            if [ -f notarization_log.json ]; then
              echo "=== NOTARIZATION LOG ==="
              cat notarization_log.json
              echo "========================"
            fi
          fi

          exit 0
        fi

    - name: Generate Release Notes from CHANGELOG
      id: release_notes
      env:
        RUN_NUMBER: ${{ github.run_number }}
      run: |
        VERSION="3.1.${RUN_NUMBER}"

        # Extract [Unreleased] section from CHANGELOG.md
        bash extract-changelog.sh CHANGELOG.md MCPServerManager/build/release-notes.html MCPServerManager/build/release-notes.md

        # Add version info to HTML
        cat >> MCPServerManager/build/release-notes.html << VERSION_INFO
          <p style="margin-top: 20px; font-size: 12px; color: #666;">
            <strong>Version:</strong> ${VERSION}<br>
            <strong>Build:</strong> ${RUN_NUMBER}
          </p>
        </body>
        </html>
        VERSION_INFO

        echo "‚úÖ Release notes generated from CHANGELOG.md"

    - name: Generate and Sign Appcast
      working-directory: MCPServerManager/build
      env:
        REPO: ${{ github.repository }}
        RUN_NUMBER: ${{ github.run_number }}
        SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
      run: |
        VERSION="3.1.${RUN_NUMBER}"
        PUBDATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
        DMG_PATH="MCP-Server-Manager-v${VERSION}.dmg"

        # Get DMG file size and signature
        DMG_SIZE=$(stat -f%z "$DMG_PATH" 2>/dev/null || stat -c%s "$DMG_PATH" 2>/dev/null || echo "0")

        # Read release notes HTML and escape for XML
        RELEASE_NOTES=$(<release-notes.html)

        # Create temp directory for archives
        mkdir -p archives
        cp "$DMG_PATH" "archives/"

        # Copy release notes with matching DMG name pattern (Sparkle requirement)
        cp release-notes.html "archives/MCP-Server-Manager-v${VERSION}.html"

        # Create private key file for Sparkle signing
        if [ -n "$SPARKLE_PRIVATE_KEY" ]; then
          # Write the key to file (ensure proper line endings)
          printf "%s" "$SPARKLE_PRIVATE_KEY" > sparkle_private_key.txt

          # Debug: Check if key file was created
          if [ ! -s sparkle_private_key.txt ]; then
            echo "‚ö†Ô∏è  Error: Private key file is empty"
            echo "‚ö†Ô∏è  Falling back to unsigned appcast"
          else
            echo "‚úÖ Private key file created ($(wc -c < sparkle_private_key.txt) bytes)"

            # Use generate_appcast with the archives directory
            /usr/local/bin/generate_appcast \
              --ed-key-file sparkle_private_key.txt \
              --download-url-prefix "https://github.com/${REPO}/releases/download/latest/" \
              --release-notes-url-prefix "https://github.com/${REPO}/releases/download/latest/" \
              archives/ || echo "‚ö†Ô∏è  generate_appcast failed, will fall back to unsigned"
          fi

          # Move generated appcast and HTML to current directory
          if [ -f archives/appcast.xml ]; then
            mv archives/appcast.xml .
            cp "archives/MCP-Server-Manager-v${VERSION}.html" .
            echo "‚úÖ Signed appcast generated successfully"
          else
            echo "‚ö†Ô∏è  generate_appcast failed, creating unsigned appcast"
            cat > appcast.xml << APPCAST_EOF
        <?xml version="1.0" encoding="utf-8"?>
        <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
          <channel>
            <title>MCP Server Manager</title>
            <language>en</language>
            <item>
              <title>Version ${VERSION}</title>
              <pubDate>${PUBDATE}</pubDate>
              <sparkle:version>${VERSION}</sparkle:version>
              <sparkle:shortVersionString>3.1</sparkle:shortVersionString>
              <link>https://github.com/${REPO}/releases</link>
              <sparkle:releaseNotesLink>https://github.com/${REPO}/releases/download/latest/${VERSION}.html</sparkle:releaseNotesLink>
              <description><![CDATA[
                ${RELEASE_NOTES}
              ]]></description>
              <enclosure url="https://github.com/${REPO}/releases/download/latest/${DMG_PATH}"
                         length="${DMG_SIZE}"
                         type="application/octet-stream"/>
            </item>
          </channel>
        </rss>
        APPCAST_EOF
            echo "‚úÖ Unsigned appcast created with release notes"
          fi

          # Cleanup
          rm -f sparkle_private_key.txt
        else
          echo "‚ö†Ô∏è  SPARKLE_PRIVATE_KEY not set - creating unsigned appcast"
          cat > appcast.xml << APPCAST_EOF
        <?xml version="1.0" encoding="utf-8"?>
        <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
          <channel>
            <title>MCP Server Manager</title>
            <language>en</language>
            <item>
              <title>Version ${VERSION}</title>
              <pubDate>${PUBDATE}</pubDate>
              <sparkle:version>${VERSION}</sparkle:version>
              <sparkle:shortVersionString>3.1</sparkle:shortVersionString>
              <link>https://github.com/${REPO}/releases</link>
              <sparkle:releaseNotesLink>https://github.com/${REPO}/releases/download/latest/${VERSION}.html</sparkle:releaseNotesLink>
              <description><![CDATA[
                ${RELEASE_NOTES}
              ]]></description>
              <enclosure url="https://github.com/${REPO}/releases/download/latest/${DMG_PATH}"
                         length="${DMG_SIZE}"
                         type="application/octet-stream"/>
            </item>
          </channel>
        </rss>
        APPCAST_EOF
          echo "‚úÖ Unsigned appcast created with release notes"
        fi

    - name: List build artifacts
      run: |
        echo "Build directory contents:"
        ls -la MCPServerManager/build/ || echo "No build directory"
        find . -name "*.dmg" -type f || echo "No DMG files found"
        find . -name "*.app" -type d || echo "No APP bundles found"
        find . -name "appcast.xml" -type f || echo "No appcast.xml found"
        echo "Widget extension check:"
        ls -la MCPServerManager/build/MCP-Server-Manager.app/Contents/PlugIns/ 2>/dev/null || echo "No PlugIns"

    - name: Upload DMG artifact
      uses: actions/upload-artifact@v4
      if: success()
      with:
        name: mcp-server-manager-v3.1.${{ github.run_number }}
        path: MCPServerManager/build/MCP-Server-Manager-v*.dmg
        retention-days: 30

    - name: Delete old latest release
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/swifty'
      run: |
        gh release delete latest -y || true
        git push origin :refs/tags/latest || true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create or Update Release
      uses: softprops/action-gh-release@v1
      if: startsWith(github.ref, 'refs/tags/') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/swifty'
      with:
        tag_name: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || 'latest' }}
        name: ${{ startsWith(github.ref, 'refs/tags/') && format('Release {0}', github.ref_name) || format('Latest Build v3.1.{0}', github.run_number) }}
        body_path: MCPServerManager/build/release-notes.md
        generate_release_notes: false
        prerelease: false
        files: |
          MCPServerManager/build/MCP-Server-Manager-v*.dmg
          MCPServerManager/build/appcast.xml
          MCPServerManager/build/*.html
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Cleanup keychain
      if: always()
      run: |
        security delete-keychain build.keychain || true
