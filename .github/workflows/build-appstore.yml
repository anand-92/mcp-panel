name: Build for Mac App Store

on:
  workflow_dispatch:
    inputs:
      upload_to_appstore:
        description: 'Upload to App Store Connect after build'
        required: false
        type: boolean
        default: true
  push:
    branches:
      - main
      - swifty
    tags:
      - 'appstore-v*'

jobs:
  build-appstore:
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Import certificates
      env:
        MAC_APP_STORE_CERT: ${{ secrets.MAC_APP_STORE_CERT }}
        MAC_INSTALLER_CERT: ${{ secrets.MAC_INSTALLER_CERT }}
      run: |
        # Create temporary keychain
        security create-keychain -p actions build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p actions build.keychain
        security set-keychain-settings -t 3600 -u build.keychain

        # Decode and import App Store signing certificate (no password)
        echo "$MAC_APP_STORE_CERT" | base64 --decode > appstore_cert.p12
        security import appstore_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A

        # Decode and import Installer certificate (no password)
        echo "$MAC_INSTALLER_CERT" | base64 --decode > installer_cert.p12
        security import installer_cert.p12 -k build.keychain -P "" -T /usr/bin/codesign -T /usr/bin/productsign -A

        # Set partition list
        security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k actions build.keychain

        # Verify certificates
        echo "Imported certificates:"
        security find-identity -v -p codesigning

        # Clean up
        rm appstore_cert.p12 installer_cert.p12

    - name: Build Swift app
      working-directory: MCPServerManager
      run: |
        # Build for native architecture (GitHub runners are arm64)
        swift build -c release

        # Verify binary was created
        ls -la .build/release/
        file .build/release/MCPServerManager

    - name: Create .app bundle
      run: |
        # Auto-increment version based on run number (max 3 components for App Store)
        VERSION_NUMBER="2.1.${{ github.run_number }}"

        BUILD_DIR="MCPServerManager/build-appstore"
        APP_NAME="MCP Server Manager"
        APP_PATH="$BUILD_DIR/$APP_NAME.app"

        # Create structure
        mkdir -p "$APP_PATH/Contents/MacOS"
        mkdir -p "$APP_PATH/Contents/Resources"
        mkdir -p "$APP_PATH/Contents/Frameworks"

        # Copy binary
        cp MCPServerManager/.build/release/MCPServerManager "$APP_PATH/Contents/MacOS/"

        # Copy Sparkle framework (required even for App Store builds as it's linked at compile time)
        # The app has runtime detection to disable Sparkle functionality in App Store builds
        if [ -d "MCPServerManager/.build/release/Sparkle.framework" ]; then
          cp -R MCPServerManager/.build/release/Sparkle.framework "$APP_PATH/Contents/Frameworks/"
          echo "âœ… Sparkle.framework copied"
        else
          echo "âš ï¸ Warning: Sparkle.framework not found - this may cause crashes"
          ls -la MCPServerManager/.build/release/
        fi
        
        # Copy app icon
        cp MCPServerManager/icons/AppIcon.icns "$APP_PATH/Contents/Resources/AppIcon.icns"

        # Copy provisioning profile
        cp embedded.provisionprofile "$APP_PATH/Contents/embedded.provisionprofile"

        # Create Info.plist with dynamic version
        cat > "$APP_PATH/Contents/Info.plist" << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>MCPServerManager</string>
            <key>CFBundleIdentifier</key>
            <string>com.mcpmanager.app</string>
            <key>CFBundleName</key>
            <string>MCP Server Manager</string>
            <key>CFBundleDisplayName</key>
            <string>MCP Server Manager</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleShortVersionString</key>
            <string>$VERSION_NUMBER</string>
            <key>CFBundleVersion</key>
            <string>$GITHUB_RUN_NUMBER</string>
            <key>LSMinimumSystemVersion</key>
            <string>13.0</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
            <key>LSApplicationCategoryType</key>
            <string>public.app-category.developer-tools</string>
            <key>NSHumanReadableCopyright</key>
            <string>Copyright Â© 2025 Nikhil Anand. All rights reserved.</string>
        </dict>
        </plist>
        EOF

        echo "VERSION_NUMBER=$VERSION_NUMBER" >> $GITHUB_ENV

    - name: Sign app bundle
      run: |
        BUILD_DIR="MCPServerManager/build-appstore"
        APP_NAME="MCP Server Manager"
        APP_PATH="$BUILD_DIR/$APP_NAME.app"

        # Find signing identity
        APP_SIGNING_IDENTITY=$(security find-identity -v -p codesigning | grep "3rd Party Mac Developer Application" | head -1 | awk -F'"' '{print $2}')

        echo "Signing with: $APP_SIGNING_IDENTITY"

        # Sign the app
        codesign --deep --force --sign "$APP_SIGNING_IDENTITY" \
          --entitlements appstore.entitlements \
          --options runtime \
          --timestamp \
          "$APP_PATH"

        # Verify
        codesign --verify --deep --strict --verbose=2 "$APP_PATH"
        echo "âœ… App bundle signed successfully"

    - name: Create PKG installer
      run: |
        BUILD_DIR="MCPServerManager/build-appstore"
        APP_NAME="MCP Server Manager"
        APP_PATH="$BUILD_DIR/$APP_NAME.app"
        PKG_PATH="$BUILD_DIR/MCPServerManager-v${VERSION_NUMBER}.pkg"

        # Find installer identity (search all identities, not just codesigning)
        INSTALLER_IDENTITY=$(security find-identity -v | grep "3rd Party Mac Developer Installer" | head -1 | awk -F'"' '{print $2}')

        echo "Creating PKG with: $INSTALLER_IDENTITY"

        # Create PKG
        productbuild --component "$APP_PATH" /Applications \
          --sign "$INSTALLER_IDENTITY" \
          "$PKG_PATH"

        # Verify
        pkgutil --check-signature "$PKG_PATH"
        echo "âœ… PKG created successfully"

        echo "PKG_PATH=$PKG_PATH" >> $GITHUB_ENV

    - name: Upload PKG artifact
      uses: actions/upload-artifact@v4
      with:
        name: mcp-server-manager-appstore-${{ env.VERSION_NUMBER }}
        path: MCPServerManager/build-appstore/*.pkg
        retention-days: 90

    - name: Upload to App Store Connect
      if: github.event.inputs.upload_to_appstore == 'true' || startsWith(github.ref, 'refs/tags/appstore-v') || github.event_name == 'push'
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        echo "ðŸ“¤ Uploading to App Store Connect..."

        # Use altool to upload the package
        # Note: While marked as deprecated, this is still the recommended method for CI/CD
        # until full migration to App Store Connect API
        xcrun altool --upload-package "$PKG_PATH" \
          --type macos \
          --username "$APPLE_ID" \
          --password "$APPLE_APP_SPECIFIC_PASSWORD" \
          --verbose

        echo "âœ… Upload complete! Check App Store Connect for processing status."
        echo "ðŸ”— https://appstoreconnect.apple.com/apps"

    # NOTE: We do NOT create GitHub releases for App Store builds
    # App Store PKGs should only be uploaded to App Store Connect
    # They cannot be installed without App Store approval
    # Artifacts are available in Actions for 90 days for internal use

    - name: Cleanup keychain
      if: always()
      run: |
        security delete-keychain build.keychain || true
